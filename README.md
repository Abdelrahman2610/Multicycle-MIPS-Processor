# Multicycle MIPS Processor Implementation

## Overview
This repository contains a detailed Verilog implementation of a multicycle MIPS processor, crafted to execute a carefully selected subset of MIPS instructions. The supported instruction set includes R-type operations (ADD, SUB, AND, OR, SLT), load/store instructions (lw, sw), branch instructions (beq), jump instructions (j), and immediate operations (addi). The design adheres to a 5-stage pipeline architecture—Fetch, Decode, Execute, Memory, and Writeback—tailored for educational exploration and hardware design experimentation. The project comprises a control unit module responsible for state-based instruction control, a top-level module that integrates the processor's pipeline, memory, and register components, and an extensive testbench to validate the processor's operational integrity.

## Features
- **Multicycle Pipeline**: Implements a 5-stage pipeline with distinct states (Fetch, Decode, Execute, Memory, Writeback) to process instructions across multiple clock cycles, promoting modularity, debuggability, and a deeper understanding of pipelined architectures.
- **Instruction Support**: Fully supports a range of MIPS instructions, with control signals dynamically generated by the control unit based on the opcode and current pipeline state, ensuring flexibility for instruction set extensions.
- **Memory and Register Management**: Incorporates 32-word instruction and data memory arrays, alongside a 32-register file, both initialized with a test program to demonstrate core functionality, including arithmetic, logical, and memory access operations.
- **Testbench Integration**: Features a robust testbench that simulates the processor with a predefined instruction sequence, verifying correct memory writes, register updates, and state transitions with detailed output monitoring.
- **Simulation Output**: Provides real-time monitoring of critical signals (time, data address, write data) to facilitate debugging, performance analysis, and validation of the processor's behavior.
- **Modular Design**: Recently refactored into submodules (ALU, register file) to enhance maintainability and scalability, though this refactoring remains untested due to current simulation constraints.

## Repository Structure
```
mips-processor/
├── src/                # Contains the core Verilog source files
│   ├── controller.v    # Module defining the control unit logic, managing state-based instruction control signals
│   ├── top.v           # Top-level module integrating the processor pipeline, memory, registers, and control unit
│   ├── alu.v           # Module implementing the Arithmetic Logic Unit for arithmetic and logical operations
│   ├── regfile.v       # Module managing the 32-register file with synchronous read and write operations
│   ├── params.v        # Configuration file containing constants, state encodings, and opcode definitions
├── test/               # Houses test-related Verilog files
│   └── testbench.v     # Testbench module simulating the processor with a sample program and verification logic
├── README.md           # This file providing a comprehensive project overview, setup instructions, and usage details
└── .gitignore          # Configuration file to exclude simulation artifacts, backup files, and temporary outputs
```

## Setup and Simulation
### Prerequisites
- **Verilog Simulator**: A compatible simulator such as ModelSim, QuestaSim, or an open-source alternative like Icarus Verilog is required to compile and simulate the design.
- **Development Environment**: A text editor or IDE with Verilog support, such as VS Code with the Verilog HDL extension, ModelSim's built-in editor, or Quartus II, is recommended for code editing and debugging.
- **System Requirements**: A system with at least 4GB of RAM and a multi-core processor is advised to handle simulation workloads efficiently, though lower specifications may suffice for small-scale testing.

### Installation and Simulation Steps
1. **Clone the Repository**:
   ```
   git clone https://github.com/Abdelrahman2610/Multicycle-MIPS-Processor.git
   cd Multicycle-MIPS-Processor
   ```
2. **Compile the Verilog Files**:
   - Using ModelSim, execute the following commands in the console:
     ```
     vlib work
     vlog src/*.v test/*.v
     ```
   - For Icarus Verilog, use:
     ```
     iverilog -o mips_testbench test/testbench.v src/*.v
     ```
3. **Run the Simulation**:
   - In ModelSim:
     ```
     vsim testbench -c -do "run -all; quit"
     ```
   - In Icarus Verilog:
     ```
     vvp mips_testbench
     ```
4. **Analyze Results**:
   - Monitor the console output for simulation progress. The testbench is configured to expect a successful write operation to memory address 84 with data 7, signaled by the message "Simulation succeeded". The `$monitor` task provides a continuous log of `dataadr` and `writedata` values, enabling users to track the processor's state and detect anomalies over time.

## Usage
The testbench initializes the multicycle MIPS processor with a sample program embedded in the instruction memory. This program comprises a sequence of 18 instructions, including arithmetic (addi), logical (or, and, slt), and memory access (sw, lw) operations, designed to test the pipeline's functionality. The sequence culminates in a write operation to address 84 with data 7, which the testbench verifies. The simulation operates with a 10ns clock period, and the output displays the simulation time, data address, and write data for each cycle where the `memwrite` signal is active. This detailed output allows users to validate the processor's correct execution, assess timing behavior, and identify potential logic or synchronization issues.

## Contributing
We enthusiastically welcome contributions to enhance this multicycle MIPS processor implementation! To contribute effectively:
- Fork the repository and create a new branch for your feature, bug fix, or enhancement (e.g., `feature/new-instruction`).
- Adhere to Verilog coding standards, including consistent 4-space indentation, comprehensive inline comments, and modular design practices.
- Submit a pull request with a detailed commit message and description, including testing results or simulation logs where applicable.
- Ensure all modifications are rigorously tested with the provided testbench or supplemented with additional test cases to maintain design integrity.

## Acknowledgments
This project was developed as an educational exercise to deepen the understanding of digital design principles and Verilog programming, inspired by the MIPS architecture documentation and hardware design communities. Special thanks to the open-source Verilog community, online tutorials, and academic resources that have guided its development. Contributions and suggestions from the GitHub community are gratefully acknowledged and anticipated.
